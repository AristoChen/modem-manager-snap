From 496499dd3993f14b72cca3fb79a326eb24aff837 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Alfonso=20S=C3=A1nchez-Beato?=
 <alfonso.sanchez-beato@canonical.com>
Date: Mon, 29 Oct 2018 14:06:43 +0100
Subject: [PATCH 11/17] plano: override load_power_state_finish

Override load_power_state_finish and use GTask in the plugin. This way
we avoid a crash that happened because we were using GSimpleAsyncResult
in load_power_state while using load_power_state_finish from the parent
class, which had switched to GTask in latest MM. Fixes LP: #1800113.
---
 plugins/plano/mm-broadband-modem-plano.c | 74 ++++++++++++------------
 1 file changed, 38 insertions(+), 36 deletions(-)

diff --git a/plugins/plano/mm-broadband-modem-plano.c b/plugins/plano/mm-broadband-modem-plano.c
index 6abb6ea..05d2291 100644
--- a/plugins/plano/mm-broadband-modem-plano.c
+++ b/plugins/plano/mm-broadband-modem-plano.c
@@ -53,15 +53,31 @@ do_nothing_cb (GObject *source_object,
 }
 
 /*****************************************************************************/
-/* Power state loading (Modem interface) */
+/* Power state loading (Modem interface) - workaround to wait for SIM */
+
+static MMModemPowerState
+load_power_state_finish (MMIfaceModem *self,
+                         GAsyncResult *res,
+                         GError **error)
+{
+    GError *inner_error = NULL;
+    gssize value;
+
+    value = g_task_propagate_int (G_TASK (res), &inner_error);
+    if (inner_error) {
+        g_propagate_error (error, inner_error);
+        return MM_MODEM_POWER_STATE_UNKNOWN;
+    }
+    return (MMModemPowerState)value;
+}
 
 static gboolean
 complete_cfun (gpointer user_data)
 {
-    GSimpleAsyncResult *simple = user_data;
+    GTask *task = user_data;
 
-    g_simple_async_result_complete (simple);
-    g_object_unref (simple);
+    g_task_return_int (task, MM_MODEM_POWER_STATE_ON);
+    g_object_unref (task);
 
     return FALSE;
 }
@@ -69,25 +85,22 @@ complete_cfun (gpointer user_data)
 static void
 modem_ready (MMBaseModem *self,
              GAsyncResult *res,
-             GSimpleAsyncResult *simple)
+             GTask *task)
 {
     const gchar *response;
     GError *error = NULL;
 
     response = mm_base_modem_at_command_finish (MM_BASE_MODEM (self), res, &error);
     if (!response) {
-        g_simple_async_result_take_error (simple, error);
-        g_simple_async_result_complete (simple);
-        g_object_unref (simple);
+        g_task_return_error (task, error);
+        g_object_unref (task);
         return;
     }
 
-    g_simple_async_result_set_op_res_gpointer (simple, GUINT_TO_POINTER (MM_MODEM_POWER_STATE_ON), NULL);
-
     /* If we access the SIM immediately after powering up we get an error, we
      * need to wait a bit to make sure we can access it.
      */
-    g_timeout_add_seconds (2, complete_cfun, simple);
+    g_timeout_add_seconds (2, complete_cfun, task);
 }
 
 static void
@@ -95,12 +108,9 @@ load_power_state (MMIfaceModem *self,
                   GAsyncReadyCallback callback,
                   gpointer user_data)
 {
-    GSimpleAsyncResult *result;
+    GTask *task;
 
-    result = g_simple_async_result_new (G_OBJECT (self),
-                                        callback,
-                                        user_data,
-                                        load_power_state);
+    task = g_task_new (self, NULL, callback, user_data);
 
     /* Instead of asking for the current power state, we turn it on so we can
      * access the SIM when initializing. MM will switch the state back to the
@@ -111,7 +121,7 @@ load_power_state (MMIfaceModem *self,
                               6,
                               FALSE,
                               (GAsyncReadyCallback)modem_ready,
-                              result);
+                              task);
 }
 
 /*****************************************************************************/
@@ -231,7 +241,6 @@ modem_create_bearer_finish (MMIfaceModem *self,
                             GAsyncResult *res,
                             GError **error)
 {
-    MMBaseBearer *bearer;
     unsigned pid;
 
     pid = get_uint_property (G_OBJECT (self), MM_BASE_MODEM_PRODUCT_ID);
@@ -239,29 +248,24 @@ modem_create_bearer_finish (MMIfaceModem *self,
     if (pid == PID_PLANO_HE910)
         return iface_modem_parent->create_bearer_finish (self, res, error);
 
-    bearer = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (res));
-    mm_dbg ("New Plano bearer created at DBus path '%s'", mm_base_bearer_get_path (bearer));
-
-    return g_object_ref (bearer);
+    return g_task_propagate_pointer (G_TASK (res), error);
 }
 
 static void
 broadband_bearer_plano_new_ready (GObject *source,
-                                   GAsyncResult *res,
-                                   GSimpleAsyncResult *simple)
+                                  GAsyncResult *res,
+                                  GTask *task)
 {
     MMBaseBearer *bearer = NULL;
     GError *error = NULL;
 
     bearer = mm_broadband_bearer_plano_new_finish (res, &error);
     if (!bearer)
-        g_simple_async_result_take_error (simple, error);
+        g_task_return_error (task, error);
     else
-        g_simple_async_result_set_op_res_gpointer (simple,
-                                                   bearer,
-                                                   (GDestroyNotify)g_object_unref);
-    g_simple_async_result_complete (simple);
-    g_object_unref (simple);
+        g_task_return_pointer (task, bearer, g_object_unref);
+
+    g_object_unref (task);
 }
 
 static void
@@ -270,7 +274,7 @@ modem_create_bearer (MMIfaceModem *self,
                      GAsyncReadyCallback callback,
                      gpointer user_data)
 {
-    GSimpleAsyncResult *result;
+    GTask *task;
     unsigned vid, pid;
 
     vid = get_uint_property (G_OBJECT (self), MM_BASE_MODEM_VENDOR_ID);
@@ -283,16 +287,13 @@ modem_create_bearer (MMIfaceModem *self,
         return;
     }
 
-    result = g_simple_async_result_new (G_OBJECT (self),
-                                        callback,
-                                        user_data,
-                                        modem_create_bearer);
+    task = g_task_new (self, NULL, callback, user_data);
 
     mm_broadband_bearer_plano_new (MM_BROADBAND_MODEM (self),
                                   properties,
                                   NULL, /* cancellable */
                                   (GAsyncReadyCallback)broadband_bearer_plano_new_ready,
-                                  result);
+                                  task);
 }
 
 /*****************************************************************************/
@@ -324,6 +325,7 @@ iface_modem_init (MMIfaceModem *iface)
     iface_modem_parent = g_type_interface_peek_parent (iface);
 
     iface->load_power_state = load_power_state;
+    iface->load_power_state_finish = load_power_state_finish;
 
     /* Disable AT commands that return errors after +CFUN=1 */
     iface->setup_flow_control = NULL;
-- 
2.17.1

