From 0b6b0b918ae3c9735b20f87422758ec8b667583f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Alfonso=20S=C3=A1nchez-Beato?=
 <alfonso.sanchez-beato@canonical.com>
Date: Mon, 27 Aug 2018 11:15:30 +0200
Subject: [PATCH 06/17] Reset the modem on MBIM NOT_OPENED error for HL7588

Reset the modem for said condition so connection can be recovered
after resuming from S4.
---
 src/mm-broadband-modem-mbim.c | 106 ++++++++++++++++++++++++++++++++++
 1 file changed, 106 insertions(+)

diff --git a/src/mm-broadband-modem-mbim.c b/src/mm-broadband-modem-mbim.c
index fa62485..aa6e006 100644
--- a/src/mm-broadband-modem-mbim.c
+++ b/src/mm-broadband-modem-mbim.c
@@ -20,6 +20,10 @@
 #include <string.h>
 #include <unistd.h>
 #include <ctype.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
 
 #include "mm-modem-helpers-mbim.h"
 #include "mm-broadband-modem-mbim.h"
@@ -110,6 +114,10 @@ struct _MMBroadbandModemMbimPrivate {
 
     GList *pco_list;
 
+    /* Process function errors */
+    guint function_error_id;
+    guint already_reset;
+
     /* 3GPP registration helpers */
     gchar *current_operator_id;
     gchar *current_operator_name;
@@ -3293,6 +3301,91 @@ device_notification_cb (MbimDevice *device,
     }
 }
 
+
+#define VID_SIERRA_HL7588 0x413C
+#define PID_SIERRA_HL7588 0x81C8
+#define VID_SIERRA_HL7588_DELL 0x1519
+#define PID_SIERRA_HL7588_DELL 0x0443
+
+static unsigned
+get_uint_property (GObject *obj, const gchar *property_name)
+{
+    GValue value = G_VALUE_INIT;
+
+    g_value_init (&value, G_TYPE_UINT);
+    g_object_get_property (obj, property_name, &value);
+    return g_value_get_uint (&value);
+}
+
+static gboolean
+check_is_hl7588 (MMBroadbandModemMbim *self)
+{
+    unsigned vid, pid;
+
+    vid = get_uint_property (G_OBJECT (self), MM_BASE_MODEM_VENDOR_ID);
+    pid = get_uint_property (G_OBJECT (self), MM_BASE_MODEM_PRODUCT_ID);
+
+    if ((VID_SIERRA_HL7588 == vid && PID_SIERRA_HL7588 == pid) ||
+        (VID_SIERRA_HL7588_DELL == vid && PID_SIERRA_HL7588_DELL == pid))
+        return TRUE;
+
+    return FALSE;
+}
+
+static void
+function_error_cb (MbimDevice *device,
+                   GError *function_error,
+                   MMBroadbandModemMbim *self)
+{
+    /* If a NOT_OPENED error is received for the Sierra HL7588, chances are that
+     * we are just out of hibernate and the modem is in a bad state. To recover,
+     * we send a reset command to the modem. At this point MM serial ports
+     * could be closed due to hangups being received, so we resort to open
+     * directly the port and sending the raw command. The reset makes the
+     * current MM instance disappear and a new one is created, in a good state.
+     */
+    if (g_error_matches (function_error,
+                         MBIM_PROTOCOL_ERROR, MBIM_PROTOCOL_ERROR_NOT_OPENED)
+        && check_is_hl7588 (self)) {
+        int fd;
+        ssize_t written;
+        const char reset_cmd[] = "AT+CFUN=16\r";
+        MMPortSerialAt *at_port;
+        char port_name[128];
+
+        /* Sending reset only once, as the command resets the HW and forces the
+         * creation of a new modem object.
+         */
+        if (self->priv->already_reset)
+            return;
+
+        mm_dbg ("NOT_OPENED received for Sierra HL7588");
+
+        at_port = mm_base_modem_peek_best_at_port (MM_BASE_MODEM (self), NULL);
+        if (at_port)
+            snprintf (port_name, sizeof port_name, "/dev/%s",
+                      mm_port_get_device (MM_PORT (at_port)));
+        else
+            strcpy (port_name, "/dev/ttyACM0");
+
+        fd = open (port_name, O_RDWR);
+        if (fd == -1) {
+            mm_dbg ("Error cannot open port: %s (%d)",  strerror (errno), errno);
+            return;
+        }
+        written = write (fd, reset_cmd, sizeof reset_cmd - 1);
+        if (written == -1) {
+            mm_dbg ("Error cannot write: %s (%d)", strerror (errno), errno);
+            close (fd);
+            return;
+        }
+        mm_dbg ("Written %s (%zd) on %s", reset_cmd, written, port_name);
+
+        close (fd);
+        self->priv->already_reset = TRUE;
+    }
+}
+
 static void
 common_setup_cleanup_unsolicited_events_sync (MMBroadbandModemMbim *self,
                                               MbimDevice           *device,
@@ -3320,6 +3413,13 @@ common_setup_cleanup_unsolicited_events_sync (MMBroadbandModemMbim *self,
                                   MBIM_DEVICE_SIGNAL_INDICATE_STATUS,
                                   G_CALLBACK (device_notification_cb),
                                   self);
+
+        if (!self->priv->function_error_id)
+            self->priv->function_error_id =
+                g_signal_connect (device,
+                                  MBIM_DEVICE_SIGNAL_ERROR,
+                                  G_CALLBACK (function_error_cb),
+                                  self);
     } else {
         /* Don't remove the signal if there are still listeners interested */
         if (self->priv->setup_flags == PROCESS_NOTIFICATION_FLAG_NONE &&
@@ -3328,6 +3428,12 @@ common_setup_cleanup_unsolicited_events_sync (MMBroadbandModemMbim *self,
             g_signal_handler_disconnect (device, self->priv->notification_id);
             self->priv->notification_id = 0;
         }
+
+        if (self->priv->function_error_id &&
+            g_signal_handler_is_connected (device, self->priv->function_error_id)) {
+            g_signal_handler_disconnect (device, self->priv->function_error_id);
+            self->priv->function_error_id = 0;
+        }
     }
 }
 
-- 
2.17.1

