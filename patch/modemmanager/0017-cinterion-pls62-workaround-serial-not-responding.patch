From 25469accc6f4b1286318086ede1bb7ee79248957 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Alfonso=20S=C3=A1nchez-Beato?=
 <alfonso.sanchez-beato@canonical.com>
Date: Mon, 24 Jun 2019 14:23:48 +0200
Subject: [PATCH 17/17] cinterion: pls62: workaround serial not responding

Do not try to deactivate the PDP context for the Gemalto PLS62-W modem,
let NM do the job for us. The reason is that due to a modem firmware
bug, if the timing between pppd and us deactivating is unfortunate, the
port ends up in a state in which it is unusable. Note also that this LTE
modem cannot really disconnect while attached, so the AT command always
returns an error anyway.

To perform this, the disconnect 3gpp functions have been implemented
in the PLS62 bearer. Fixes LP: #1829293.
---
 plugins/cinterion/mm-broadband-bearer-pls62.c | 274 ++++++++++++++++++
 1 file changed, 274 insertions(+)

diff --git a/plugins/cinterion/mm-broadband-bearer-pls62.c b/plugins/cinterion/mm-broadband-bearer-pls62.c
index 3d9b147..f2a7ae5 100644
--- a/plugins/cinterion/mm-broadband-bearer-pls62.c
+++ b/plugins/cinterion/mm-broadband-bearer-pls62.c
@@ -282,6 +282,278 @@ dial_3gpp (MMBroadbandBearer   *self,
     dial_3gpp_context_step (task);
 }
 
+/*****************************************************************************/
+/* Detailed disconnect context */
+
+typedef struct {
+    MMBaseModem *modem;
+    MMPortSerialAt *primary;
+    MMPortSerialAt *secondary;
+    MMPort *data;
+
+    /* 3GPP-specific */
+    gchar *cgact_command;
+    gboolean cgact_sent;
+} DetailedDisconnectContext;
+
+static gboolean
+detailed_disconnect_finish (MMBroadbandBearer *self,
+                            GAsyncResult *res,
+                            GError **error)
+{
+    return g_task_propagate_boolean (G_TASK (res), error);
+}
+
+static void
+detailed_disconnect_context_free (DetailedDisconnectContext *ctx)
+{
+    if (ctx->cgact_command)
+        g_free (ctx->cgact_command);
+    g_object_unref (ctx->data);
+    g_object_unref (ctx->primary);
+    if (ctx->secondary)
+        g_object_unref (ctx->secondary);
+    g_object_unref (ctx->modem);
+    g_free (ctx);
+}
+
+static DetailedDisconnectContext *
+detailed_disconnect_context_new (MMBroadbandModem *modem,
+                                 MMPortSerialAt *primary,
+                                 MMPortSerialAt *secondary,
+                                 MMPort *data)
+{
+    DetailedDisconnectContext *ctx;
+
+    ctx = g_new0 (DetailedDisconnectContext, 1);
+    ctx->modem = MM_BASE_MODEM (g_object_ref (modem));
+    ctx->primary = g_object_ref (primary);
+    ctx->secondary = (secondary ? g_object_ref (secondary) : NULL);
+    ctx->data = g_object_ref (data);
+
+    return ctx;
+}
+
+/*****************************************************************************/
+/* 3GPP disconnect */
+
+static void
+cgact_data_ready (MMBaseModem *modem,
+                  GAsyncResult *res,
+                  GTask *task)
+{
+
+    GError *error = NULL;
+
+    /* Ignore errors for now */
+    mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (error) {
+        mm_dbg ("PDP context deactivation failed (not fatal): %s", error->message);
+        g_error_free (error);
+    }
+
+    g_task_return_boolean (task, TRUE);
+    g_object_unref (task);
+}
+
+static void
+data_flash_3gpp_ready (MMPortSerial *data,
+                       GAsyncResult *res,
+                       GTask *task)
+{
+    MMBroadbandBearer *self;
+    DetailedDisconnectContext *ctx;
+    GError *error = NULL;
+
+    self = g_task_get_source_object (task);
+    ctx = g_task_get_task_data (task);
+
+    mm_port_serial_flash_finish (data, res, &error);
+
+    /* We kept the serial port open during connection, now we close that open
+     * count */
+    mm_port_serial_close (data);
+
+    /* Port is disconnected; update the state */
+    mm_port_set_connected (MM_PORT (data), FALSE);
+
+    if (error) {
+        /* Ignore "NO CARRIER" response when modem disconnects and any flash
+         * failures we might encounter. Other errors are hard errors.
+         */
+        if (!g_error_matches (error,
+                              MM_CONNECTION_ERROR,
+                              MM_CONNECTION_ERROR_NO_CARRIER) &&
+            !g_error_matches (error,
+                              MM_SERIAL_ERROR,
+                              MM_SERIAL_ERROR_FLASH_FAILED)) {
+            /* Fatal */
+            g_task_return_error (task, error);
+            g_object_unref (task);
+            return;
+        }
+
+        mm_dbg ("Port flashing failed (not fatal): %s", error->message);
+        g_error_free (error);
+    }
+
+    /* Run init port sequence in the data port */
+    mm_port_serial_at_run_init_sequence (MM_PORT_SERIAL_AT (data));
+
+    /* Don't bother doing the CGACT again if it was already done on the
+     * primary or secondary port */
+    if (ctx->cgact_sent) {
+        mm_dbg ("PDP disconnection already sent");
+        g_task_return_boolean (task, TRUE);
+        g_object_unref (task);
+        return;
+    }
+
+    /* Send another CGACT on the primary port (also the data port when the modem
+     * only has one serial port) if the previous one failed.  Some modems, like
+     * the Huawei E173 (fw 11.126.15.00.445) stop responding on their primary
+     * port when the CGACT is sent on the separte data port.
+     */
+    if (MM_PORT_SERIAL (ctx->primary) == data)
+        mm_dbg ("Sending PDP context deactivation in primary/data port...");
+    else
+        mm_dbg ("Sending PDP context deactivation in primary port again...");
+
+    mm_base_modem_at_command_full (ctx->modem,
+                                   ctx->primary,
+                                   ctx->cgact_command,
+                                   10,
+                                   FALSE,
+                                   FALSE, /* raw */
+                                   NULL, /* cancellable */
+                                   (GAsyncReadyCallback)cgact_data_ready,
+                                   task);
+}
+
+static void
+data_reopen_3gpp_ready (MMPortSerial *data,
+                        GAsyncResult *res,
+                        GTask *task)
+{
+    DetailedDisconnectContext *ctx;
+    GError *error = NULL;
+
+    g_object_set (data, MM_PORT_SERIAL_AT_INIT_SEQUENCE_ENABLED, TRUE, NULL);
+
+    if (!mm_port_serial_reopen_finish (data, res, &error)) {
+        /* Fatal */
+        g_task_return_error (task, error);
+        g_object_unref (task);
+        return;
+    }
+
+    ctx = g_task_get_task_data (task);
+
+    /* Just flash the data port */
+    mm_dbg ("Flashing data port (%s)...", mm_port_get_device (MM_PORT (ctx->data)));
+    mm_port_serial_flash (MM_PORT_SERIAL (ctx->data),
+                          1000,
+                          TRUE,
+                          (GAsyncReadyCallback)data_flash_3gpp_ready,
+                          task);
+}
+
+static void
+data_reopen_3gpp (GTask *task)
+{
+    DetailedDisconnectContext *ctx;
+
+    ctx = g_task_get_task_data (task);
+
+    /* We don't want to run init sequence right away during the reopen, as we're
+     * going to flash afterwards. */
+    g_object_set (ctx->data, MM_PORT_SERIAL_AT_INIT_SEQUENCE_ENABLED, FALSE, NULL);
+
+    /* Fully reopen the port before flashing */
+    mm_dbg ("Reopening data port (%s)...", mm_port_get_device (MM_PORT (ctx->data)));
+    mm_port_serial_reopen (MM_PORT_SERIAL (ctx->data),
+                           1000,
+                           (GAsyncReadyCallback)data_reopen_3gpp_ready,
+                           task);
+}
+
+static void
+cgact_ready (MMBaseModem *modem,
+             GAsyncResult *res,
+             GTask *task)
+{
+    DetailedDisconnectContext *ctx;
+    GError *error = NULL;
+
+    ctx = g_task_get_task_data (task);
+
+    mm_base_modem_at_command_full_finish (modem, res, &error);
+    if (!error)
+        ctx->cgact_sent = TRUE;
+    else {
+        mm_dbg ("PDP context deactivation failed (not fatal): %s", error->message);
+        g_error_free (error);
+    }
+
+    data_reopen_3gpp (task);
+}
+
+static void
+disconnect_3gpp (MMBroadbandBearer *self,
+                 MMBroadbandModem *modem,
+                 MMPortSerialAt *primary,
+                 MMPortSerialAt *secondary,
+                 MMPort *data,
+                 guint cid,
+                 GAsyncReadyCallback callback,
+                 gpointer user_data)
+{
+    DetailedDisconnectContext *ctx;
+    GTask *task;
+
+    g_assert (primary != NULL);
+
+    /* Generic 3GPP plays only with SERIAL data ports */
+    g_assert (MM_IS_PORT_SERIAL (data));
+
+    ctx = detailed_disconnect_context_new (modem, primary, secondary, data);
+
+    /* If no specific CID was used, disable all PDP contexts */
+    ctx->cgact_command = (cid > 0 ?
+                          g_strdup_printf ("+CGACT=0,%d", cid) :
+                          g_strdup_printf ("+CGACT=0"));
+
+    task = g_task_new (self, NULL, callback, user_data);
+    g_task_set_task_data (task, ctx, (GDestroyNotify)detailed_disconnect_context_free);
+
+    /* If the primary port is NOT connected (doesn't have to be the data port),
+     * we'll send CGACT there */
+    if (!mm_port_get_connected (MM_PORT (ctx->primary))) {
+        mm_dbg ("Sending PDP context deactivation in primary port...");
+        mm_base_modem_at_command_full (ctx->modem,
+                                       ctx->primary,
+                                       ctx->cgact_command,
+                                       10,
+                                       FALSE,
+                                       FALSE, /* raw */
+                                       NULL, /* cancellable */
+                                       (GAsyncReadyCallback)cgact_ready,
+                                       task);
+        return;
+    }
+
+    /* If the primary port is busy with a data call, do not try to deactivate,
+     * let NM do the job for us. The reason is that due to a modem firmware bug
+     * in the PLS62-W, if the timing between pppd and us disconnecting is
+     * unfortunate, the port ends up in a state in which it is unusable. Note
+     * also that this LTE modem cannot really disconnect while attached, so
+     * trying to do so ends in error anyway.
+    */
+    mm_info ("PLS62-W modem, letting NM do the disconnect...");
+    /* Go on to reopen & flash the data/primary port */
+    data_reopen_3gpp (task);
+}
+
 /*****************************************************************************/
 /* Setup and Init Bearers */
 
@@ -336,4 +608,6 @@ mm_broadband_bearer_pls62_class_init (MMBroadbandBearerPls62Class *klass)
 
     broadband_bearer_class->dial_3gpp              = dial_3gpp;
     broadband_bearer_class->dial_3gpp_finish       = dial_3gpp_finish;
+    broadband_bearer_class->disconnect_3gpp        = disconnect_3gpp;
+    broadband_bearer_class->disconnect_3gpp_finish = detailed_disconnect_finish;
 }
-- 
2.17.1

